import boto3
import botocore
import os
import logging
import json
from decimal import Decimal
import time
import requests
from langchain.llms.bedrock import Bedrock
from langchain.embeddings import BedrockEmbeddings
from langchain.vectorstores import OpenSearchVectorSearch
from langchain.chains.retrieval_qa.base import RetrievalQA
from langchain.prompts import PromptTemplate

# Configure logger
logger = logging.getLogger()
logger.setLevel(logging.INFO)

def download_file_from_s3(bucket, key):
    """
    Download file from S3 bucket
    Parameters:
        bucket: S3 bucket name
        key: S3 object key
    Returns:
        Content of the file
    """
    s3_client = boto3.client('s3')
    try:
        response = s3_client.get_object(Bucket=bucket, Key=key)
        content = response['Body'].read()
        return content
    except botocore.exceptions.ClientError as e:
        logger.error(f"Error downloading file: {e}")
        raise

def parse_json_metadata(json_content):
    """
    Parse JSON metadata to extract specific fields
    Parameters:
        json_content: JSON content as string or bytes
    Returns:
        Formatted string with extracted fields
    """
    try:
        if isinstance(json_content, bytes):
            json_content = json_content.decode('utf-8')
        
        data = json.loads(json_content)
        
        # Extract all relevant fields from metadata JSON
        issue_id = data.get('id', f"issue_{int(time.time())}")
        timestamp = data.get('timestamp', time.strftime('%Y-%m-%d'))
        length = data.get('length', 0)
        width = data.get('width')
        # depth = data.get('width', 0)
        position = data.get('position', 'mountain')
        material = data.get('material', 'concrete')
        crack_type = data.get('crack_type', 'Longitudinal')
        crack_location = data.get('crack_location', 'A')
        image_url = data.get('image_url', '')
        
        # Format the metadata string for RAG input
        formatted_metadata = (
            f"Issue ID: {issue_id}, Timestamp: {timestamp}, Location: {position}, Material: {material}, "
            f"Crack Type: {crack_type}, Length (cm): {length}, Width (cm): {width}"
        )
        
        # Return both formatted text for RAG and raw data for DynamoDB
        return {
            'formatted_text': formatted_metadata,
            'raw_data': data
        }
    except Exception as e:
        logger.error(f"Error parsing JSON metadata: {e}")
        raise

def initialize_rag_chain():
    """
    Initialize the RAG chain using Langchain with Bedrock components
    Returns:
        Configured RAG chain
    """
    try:
        # Initialize Bedrock client
        bedrock_client = boto3.client('bedrock-runtime')
        
        # Initialize Claude LLM
        llm = Bedrock(
            client=bedrock_client,
            model_id=os.environ.get('BEDROCK_MODEL_ID', 'anthropic.claude-3-sonnet-20240229-v1:0'),
            model_kwargs={"temperature": 0.1, "max_tokens_to_sample": 2000}
        )
        
        # Initialize Bedrock embeddings
        embeddings = BedrockEmbeddings(
            client=bedrock_client,
            model_id=os.environ.get('BEDROCK_EMBEDDING_MODEL_ID', 'amazon.titan-embed-text-v1')
        )
        
        # Initialize OpenSearch vector store
        opensearch_url = os.environ.get('OPENSEARCH_ENDPOINT')
        vectorstore = OpenSearchVectorSearch(
            opensearch_url=opensearch_url,
            index_name="icam-vectors",
            embedding_function=embeddings
        )
        
        # Create prompt template with focus on risk assessment and recommended action
        prompt_template = """
        你是一個專門分析混凝土裂縫問題的專家系統。

        以下是從知識庫中找到的相關資訊：
        {context}

        現在請分析這個問題：{question}

        請只提供以下兩項資訊：
        1. 風險評估：評估此裂縫的風險等級（請明確標明是 "Low"、"Medium" 或 "High"），並簡短解釋評估理由。
        2. 建議處理方式：提供具體的修復或處理建議。

        請根據裂縫類型、位置、長度和深度，並參考知識庫資訊進行專業判斷。
        """
        
        PROMPT = PromptTemplate(
            template=prompt_template,
            input_variables=["context", "question"]
        )
        
        # Create QA chain
        qa_chain = RetrievalQA.from_chain_type(
            llm=llm,
            chain_type="stuff",
            retriever=vectorstore.as_retriever(search_kwargs={"k": 3}),
            chain_type_kwargs={"prompt": PROMPT}
        )
        
        return qa_chain
    except Exception as e:
        print(f"Error initializing RAG chain: {e}")
        raise

def validate_and_format_data(issue_data, solution):
    """
    Validate and format data according to the specified constraints
    Parameters:
        issue_data: Dict containing issue data
        solution: Solution generated by the model
    Returns:
        Formatted and validated data
    """
    try:
        # 從AI回應中提取風險等級和處理建議
        solution_text = solution if isinstance(solution, str) else json.dumps(solution)
        
        # 嘗試從回應中提取風險等級
        ai_risk_level = None
        if "風險評估" in solution_text:
            if "High" in solution_text or "高風險" in solution_text or "高" in solution_text and "風險" in solution_text:
                ai_risk_level = "High"
            elif "Medium" in solution_text or "中風險" in solution_text or "中" in solution_text and "風險" in solution_text:
                ai_risk_level = "Medium"
            elif "Low" in solution_text or "低風險" in solution_text or "低" in solution_text and "風險" in solution_text:
                ai_risk_level = "Low"
        
        # 從AI回應中提取處理建議
        ai_action = None
        if "建議處理方式" in solution_text:
            try:
                action_section = solution_text.split("建議處理方式")[1].strip()
                if action_section.startswith("：") or action_section.startswith(":"):
                    action_section = action_section[1:].strip()
                
                end_markers = ["\n", "。", ".", "，", ","]
                for marker in end_markers:
                    if marker in action_section:
                        action_section = action_section.split(marker)[0].strip()
                        break
                
                if action_section:
                    ai_action = action_section[:200]  # 增加允許長度
            except:
                for keyword in ["修復", "處理", "建議", "修補", "灌漿", "更換", "加固"]:
                    if keyword in solution_text:
                        sentences = solution_text.split("。")
                        for sentence in sentences:
                            if keyword in sentence:
                                ai_action = sentence.strip()[:200]
                                break
                        if ai_action:
                            break
        
        # 使用 S3 key作為issue_id (移除路徑和副檔名)
        issue_id = issue_data.get('s3_key', '')
        if not issue_id or issue_id == "":
            issue_id = issue_data.get('report_id', issue_data.get('id', ''))
            if not issue_id:
                # 生成隨機ID
                timestamp = time.strftime('%Y_%m_%d_%H_%M_%S')
                issue_id = f"issue_{timestamp}"
        
        # 確保issue_id只保留最後部分，不包含完整路徑
        if '/' in issue_id:
            issue_id = issue_id.split('/')[-1]
            issue_id = issue_id.split('.')[0]
        
        # 獲取或生成時間戳
        timestamp = issue_data.get('timestamp')
        if not timestamp:
            timestamp = time.strftime('%Y-%m-%d %H:%M:%S')
        
        # 驗證length (0 ~ 9999)
        try:
            length = str(float(issue_data.get('length', 0)))
        except (ValueError, TypeError):
            length = "0"
            
        # 驗證width (0 ~ 9999)
        try:
            width = str(float(issue_data.get('width', 0)))
        except (ValueError, TypeError):
            width = "0"
        
        # 獲取位置和材料
        position = issue_data.get('position', 'mountain')
        material = issue_data.get('material', 'concrete')
        
        # 獲取裂縫位置
        crack_location = issue_data.get('crack_location', issue_data.get('location', 'A'))
        
        # 驗證風險等級
        valid_risk_levels = ['Low', 'Medium', 'High']
        risk_level = issue_data.get('risk_level', '')
        
        if risk_level not in valid_risk_levels:
            if ai_risk_level in valid_risk_levels:
                risk_level = ai_risk_level
            else:
                # 根據尺寸計算風險等級
                try:
                    length_float = float(length)
                    width_float = float(width)
                    if length_float > 100 or width_float > 5:
                        risk_level = "High"
                    elif length_float > 50 or width_float > 2:
                        risk_level = "Medium"
                    else:
                        risk_level = "Low"
                except:
                    risk_level = "Low"
        
        # 獲取處理建議
        action = issue_data.get('action', '')
        if not action and ai_action:
            action = ai_action
        elif not action:
            action = "待處理"
        
        # 獲取圖片URL
        image_url = issue_data.get('image_url', '')
        
        # 獲取工程師
        engineer = issue_data.get('engineer', '張工程師')
        
        # 返回符合要求格式的資料
        return {
            'id': issue_id,
            'timestamp': timestamp,
            'length': length,
            'width': width,
            'position': position,
            'material': material,
            'crack_location': crack_location,
            'image_url': image_url,
            'engineer': engineer,
            'risk_level': risk_level,
            'action': action,
            'ai_solution': solution  # 保存完整AI回應，用於後續分析
        }
    except Exception as e:
        logger.error(f"Error in validate_and_format_data: {e}")
        # 發生錯誤時返回最小有效項目
        timestamp = time.strftime('%Y-%m-%d %H:%M:%S')
        error_id = f"ERROR-{int(time.time())}"
        return {
            'id': error_id,
            'timestamp': timestamp,
            'length': "0",
            'width': "0",
            'position': 'mountain',
            'material': 'concrete',
            'crack_location': 'A',
            'image_url': '',
            'engineer': '張工程師',
            'risk_level': 'Low',
            'action': '待處理'
        }

def store_in_dynamodb(issue_data, solution):
    """
    Store issue data and solution in DynamoDB
    Parameters:
        issue_data: Dict containing issue data
        solution: Solution generated by the model
    """
    try:
        dynamodb = boto3.resource('dynamodb')
        table = dynamodb.Table(os.environ.get('DYNAMODB_TABLE', 'issues'))
        
        # Validate and format data according to constraints
        item = validate_and_format_data(issue_data, solution)
        
        # Convert numeric values to Decimal for DynamoDB compatibility
        if 'length' in item:
            item['length'] = Decimal(str(item['length']))
        if 'width' in item:
            item['width'] = Decimal(str(item['width']))
            
        # Store item in DynamoDB
        table.put_item(Item=item)
        
        logger.info(f"Successfully stored data in DynamoDB: {item['issue_id']}")
        return True
    except Exception as e:
        logger.error(f"Error storing data in DynamoDB: {e}")
        return False


def lambda_handler(event, context):
    """
    When new folder with image & JSON metadata is created in S3, this lambda will be triggered
    to call Bedrock model for generating solution with knowledge base using Langchain RAG.
    Parameters:
        event: Dict containing the Lambda function event data
        context: Lambda runtime context
    Returns:
        Dict containing status message
    """
    try:
        # Log the incoming event
        logger.info(f"Received event: {json.dumps(event)}")
        
        # Get message from event triggered by S3
        record = event['Records'][0]
        bucket = record['s3']['bucket']['name']
        key = record['s3']['object']['key']
        
        logger.info(f"Processing S3 object: bucket={bucket}, key={key}")
        
        # 使用S3 object key作為issue_id的基礎
        # 將完整的S3 key儲存在raw_data中，讓validate_and_format_data函數處理
        
        # Process the metadata file
        logger.info(f"Downloading and parsing metadata from S3")
        
        # Download and parse JSON metadata
        json_content = download_file_from_s3(bucket, key)
        parsed_data = parse_json_metadata(json_content)
        formatted_metadata = parsed_data['formatted_text']
        raw_data = parsed_data['raw_data']
        
        # 將完整S3 key添加到raw_data中
        raw_data['s3_key'] = key
        logger.info(f"Added S3 key to raw_data: {key}")
        
        logger.info(f"Metadata parsed: {formatted_metadata}")
        
        # Initialize and run RAG chain
        logger.info("Initializing RAG chain")
        rag_chain = initialize_rag_chain()
        logger.info("Running query through RAG chain")
        solution = rag_chain.run(formatted_metadata)
        
        logger.info(f"RAG solution generated: {solution[:100]}...")
        
        # Store in DynamoDB using the raw data extracted from JSON
        logger.info("Storing data in DynamoDB")
        store_result = store_in_dynamodb(raw_data, solution)
        
        if store_result:
            # 從raw_data中提取最終使用的issue_id以記錄
            issue_id = key.split('/')[-1].split('.')[0]
            logger.info(f"Data successfully stored in DynamoDB with issue_id derived from key: {issue_id}")
        else:
            logger.error("Failed to store data in DynamoDB")
        
        return {
            'statusCode': 200,
            'body': json.dumps({
                'message': 'Analysis completed and data stored successfully',
                'issue_id': key.split('/')[-1].split('.')[0]  # 使用從key中提取的ID
            })
        }
    except Exception as e:
        logger.error(f"Error in lambda_handler: {str(e)}")
        return {
            'statusCode': 500,
            'body': json.dumps({
                'error': f"Error processing event: {str(e)}"
            })
        }