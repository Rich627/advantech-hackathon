import boto3
import botocore
import os
import logging
import json
from decimal import Decimal
import time
import requests
from langchain.llms.bedrock import Bedrock
from langchain.embeddings import BedrockEmbeddings
from langchain.vectorstores import OpenSearchVectorSearch
from langchain.chains.retrieval_qa.base import RetrievalQA
from langchain.prompts import PromptTemplate

# Configure logger
logger = logging.getLogger()
logger.setLevel(logging.INFO)

def download_file_from_s3(bucket, key):
    """
    Download file from S3 bucket
    Parameters:
        bucket: S3 bucket name
        key: S3 object key
    Returns:
        Content of the file
    """
    s3_client = boto3.client('s3')
    try:
        response = s3_client.get_object(Bucket=bucket, Key=key)
        content = response['Body'].read()
        return content
    except botocore.exceptions.ClientError as e:
        logger.error(f"Error downloading file: {e}")
        raise

def parse_json_metadata(json_content):
    """
    Parse JSON metadata to extract specific fields
    Parameters:
        json_content: JSON content as string or bytes
    Returns:
        Formatted string with extracted fields
    """
    try:
        if isinstance(json_content, bytes):
            json_content = json_content.decode('utf-8')
        
        data = json.loads(json_content)
        
        # Extract all relevant fields from metadata JSON
        issue_id = data.get('id', f"ISSUE-{int(time.time())}")
        date = data.get('date', time.strftime('%Y-%m-%d'))
        location = data.get('location', 'A1')
        crack_type = data.get('crack_type', 'Longitudinal')
        length_cm = data.get('length_cm', 0)
        depth_cm = data.get('depth_cm', 0)
        image_url = data.get('image_url', '')
        
        # Format the metadata string for RAG input
        formatted_metadata = (
            f"Issue ID: {issue_id}, Date: {date}, Location: {location}, "
            f"Crack Type: {crack_type}, Length (cm): {length_cm}, Depth (cm): {depth_cm}"
        )
        
        # Return both formatted text for RAG and raw data for DynamoDB
        return {
            'formatted_text': formatted_metadata,
            'raw_data': data
        }
    except Exception as e:
        logger.error(f"Error parsing JSON metadata: {e}")
        raise

def initialize_rag_chain():
    """
    Initialize the RAG chain using Langchain with Bedrock components
    Returns:
        Configured RAG chain
    """
    try:
        # Initialize Bedrock client
        bedrock_client = boto3.client('bedrock-runtime')
        
        # Initialize Claude LLM
        llm = Bedrock(
            client=bedrock_client,
            model_id=os.environ.get('BEDROCK_MODEL_ID', 'anthropic.claude-3-sonnet-20240229-v1:0'),
            model_kwargs={"temperature": 0.1, "max_tokens_to_sample": 2000}
        )
        
        # Initialize Bedrock embeddings
        embeddings = BedrockEmbeddings(
            client=bedrock_client,
            model_id=os.environ.get('BEDROCK_EMBEDDING_MODEL_ID', 'amazon.titan-embed-text-v1')
        )
        
        # Initialize OpenSearch vector store
        opensearch_url = os.environ.get('OPENSEARCH_ENDPOINT')
        vectorstore = OpenSearchVectorSearch(
            opensearch_url=opensearch_url,
            index_name="icam-vectors",
            embedding_function=embeddings
        )
        
        # Create prompt template with focus on risk assessment and recommended action
        prompt_template = """
        你是一個專門分析混凝土裂縫問題的專家系統。

        以下是從知識庫中找到的相關資訊：
        {context}

        現在請分析這個問題：{question}

        請只提供以下兩項資訊：
        1. 風險評估：評估此裂縫的風險等級（請明確標明是 "Low"、"Medium" 或 "High"），並簡短解釋評估理由。
        2. 建議處理方式：提供具體的修復或處理建議。

        請根據裂縫類型、位置、長度和深度，並參考知識庫資訊進行專業判斷。
        """
        
        PROMPT = PromptTemplate(
            template=prompt_template,
            input_variables=["context", "question"]
        )
        
        # Create QA chain
        qa_chain = RetrievalQA.from_chain_type(
            llm=llm,
            chain_type="stuff",
            retriever=vectorstore.as_retriever(search_kwargs={"k": 3}),
            chain_type_kwargs={"prompt": PROMPT}
        )
        
        return qa_chain
    except Exception as e:
        print(f"Error initializing RAG chain: {e}")
        raise

def validate_and_format_data(issue_data, solution):
    """
    Validate and format data according to the specified constraints
    Parameters:
        issue_data: Dict containing issue data
        solution: Solution generated by the model
    Returns:
        Formatted and validated data
    """
    try:
        # 從AI回應中提取風險等級和處理建議
        solution_text = solution if isinstance(solution, str) else json.dumps(solution)
        
        # 嘗試從回應中提取風險等級 (僅當metadata中沒有提供時)
        ai_risk_level = None
        # 檢查風險評估關鍵詞
        if "風險評估" in solution_text:
            # 尋找風險等級關鍵詞
            if "High" in solution_text or "高風險" in solution_text or "高" in solution_text and "風險" in solution_text:
                ai_risk_level = "High"
            elif "Medium" in solution_text or "中風險" in solution_text or "中" in solution_text and "風險" in solution_text:
                ai_risk_level = "Medium"
            elif "Low" in solution_text or "低風險" in solution_text or "低" in solution_text and "風險" in solution_text:
                ai_risk_level = "Low"
        
        # 從AI回應中提取處理建議 (僅當metadata中沒有提供時)
        ai_action = None
        # 尋找建議處理方式部分
        if "建議處理方式" in solution_text:
            try:
                # 從"建議處理方式"後面提取文字直到下一行或句號
                action_section = solution_text.split("建議處理方式")[1].strip()
                if action_section.startswith("：") or action_section.startswith(":"):
                    action_section = action_section[1:].strip()
                
                # 提取第一個完整句子或段落
                end_markers = ["\n", "。", ".", "，", ","]
                for marker in end_markers:
                    if marker in action_section:
                        action_section = action_section.split(marker)[0].strip()
                        break
                
                if action_section:
                    ai_action = action_section[:100]  # 限制長度
            except:
                # 無法解析時的備用方案
                # 尋找可能的關鍵詞
                for keyword in ["修復", "處理", "建議", "修補", "灌漿", "更換", "加固"]:
                    if keyword in solution_text:
                        # 找到關鍵詞所在的句子
                        sentences = solution_text.split("。")
                        for sentence in sentences:
                            if keyword in sentence:
                                ai_action = sentence.strip()[:100]
                                break
                        if ai_action:
                            break
        
        # 使用S3 key作為issue_id (而不是從metadata的id欄位)
        issue_id = issue_data.get('s3_key', '')
        if not issue_id or issue_id == "":
            # 作為備用，使用metadata中的report_id (轉換為issue_id)
            issue_id = issue_data.get('report_id', issue_data.get('id', ''))
            if not issue_id:
                # 如果都沒有，生成隨機ID
                random_id = int(time.time()) % 999 + 1
                issue_id = f"ISSUE-{random_id:03d}"
        
        # 確保issue_id只保留最後部分，不包含完整路徑
        if '/' in issue_id:
            # 從路徑中提取檔案名稱
            issue_id = issue_id.split('/')[-1]
            # 移除副檔名
            issue_id = issue_id.split('.')[0]
        
        # 驗證location (A1 ~ C3)
        location = issue_data.get('location', 'A1')
        valid_locations = ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']
        if location not in valid_locations:
            location = 'A1'  # 如果無效則設為A1
        
        # 驗證crack_type
        valid_crack_types = [
            'Longitudinal', 'Transverse', 'Diagonal', 'Radial', 
            'Annular', 'Rippled', 'Network', 'Turtle-shell patterned'
        ]
        crack_type = issue_data.get('crack_type', 'Longitudinal')
        if crack_type not in valid_crack_types:
            crack_type = 'Longitudinal'  # 如果無效則設為Longitudinal
        
        # 驗證length_cm (0 ~ 9999)
        try:
            length_cm = float(issue_data.get('length_cm', 0))
            length_cm = max(0, min(9999, length_cm))  # 確保在0-9999範圍內
        except (ValueError, TypeError):
            length_cm = 0
            
        # 驗證depth_cm (0 ~ 9999)
        try:
            depth_cm = float(issue_data.get('depth_cm', 0))
            depth_cm = max(0, min(9999, depth_cm))  # 確保在0-9999範圍內
        except (ValueError, TypeError):
            depth_cm = 0
        
        # 驗證risk_level - 優先使用metadata中的值，其次是AI判斷，最後是根據尺寸計算
        valid_risk_levels = ['Low', 'Medium', 'High']
        risk_level = issue_data.get('risk_level', '')
        
        if risk_level not in valid_risk_levels:
            # 如果metadata中沒有有效值，嘗試使用AI判斷的值
            if ai_risk_level in valid_risk_levels:
                risk_level = ai_risk_level
                logger.info(f"Using AI-determined risk level: {risk_level}")
            else:
                # 如果AI也沒有判斷，根據尺寸計算
                if length_cm > 100 or depth_cm > 5:
                    risk_level = "High"
                elif length_cm > 50 or depth_cm > 2:
                    risk_level = "Medium"
                else:
                    risk_level = "Low"
                logger.info(f"Using calculated risk level: {risk_level}")
        else:
            logger.info(f"Using metadata-provided risk level: {risk_level}")
        
        # 驗證status - 優先使用metadata中的值
        valid_statuses = ['Done', 'In Progress', 'Not Started']
        status = issue_data.get('status', 'Not Started')
        if status not in valid_statuses:
            status = 'Not Started'
        
        # 獲取action - 優先使用metadata中的值，其次是AI判斷的值
        action = issue_data.get('action', '')
        if not action and ai_action:
            action = ai_action
            logger.info(f"Using AI-determined action: {action}")
        elif not action:
            action = "待處理"
        else:
            logger.info(f"Using metadata-provided action: {action}")
        
        # 獲取description - 優先使用metadata中的值，其次是AI回應
        description = issue_data.get('description', '')
        if not description:
            description = solution if isinstance(solution, str) else json.dumps(solution)
        
        # 從metadata獲取日期或使用當前日期
        date = issue_data.get('date', time.strftime('%Y-%m-%d'))
        
        # 預設工程師
        engineer = issue_data.get('engineer', '張工程師')
        
        # 獲取圖片URL
        image_url = issue_data.get('image_url', '')
        
        # 返回符合DynamoDB模式的格式化數據
        return {
            'issue_id': issue_id,      # hash key
            'date': date,              # GSI hash key
            'risk_level': risk_level,  # GSI hash key
            'status': status,          # GSI hash key
            'location': location,      # GSI hash key
            'crack_type': crack_type,  # GSI hash key
            'engineer': engineer,      # 一般屬性
            'length_cm': length_cm,    # 數值欄位
            'depth_cm': depth_cm,      # 數值欄位
            'action': action,          # 處理方式
            'description': description, # 描述
            'image_url': image_url,    # 圖片URL
            'ai_solution': solution    # 保存完整的AI回應
        }
    except Exception as e:
        logger.error(f"Error in validate_and_format_data: {e}")
        # 發生錯誤時返回最小有效項目
        return {
            'issue_id': issue_id if 'issue_id' in locals() else f"ERROR-{int(time.time())}",
            'date': time.strftime('%Y-%m-%d'),
            'risk_level': 'Low',
            'status': 'Not Started',
            'location': 'A1',
            'crack_type': 'Longitudinal',
            'engineer': '張工程師',
            'length_cm': 0,
            'depth_cm': 0,
            'action': '待處理',
            'description': '處理錯誤'
        }

def store_in_dynamodb(issue_data, solution):
    """
    Store issue data and solution in DynamoDB
    Parameters:
        issue_data: Dict containing issue data
        solution: Solution generated by the model
    """
    try:
        dynamodb = boto3.resource('dynamodb')
        table = dynamodb.Table(os.environ.get('DYNAMODB_TABLE', 'issues'))
        
        # Validate and format data according to constraints
        item = validate_and_format_data(issue_data, solution)
        
        # Convert numeric values to Decimal for DynamoDB compatibility
        if 'length_cm' in item:
            item['length_cm'] = Decimal(str(item['length_cm']))
        if 'depth_cm' in item:
            item['depth_cm'] = Decimal(str(item['depth_cm']))
            
        # Store item in DynamoDB
        table.put_item(Item=item)
        
        logger.info(f"Successfully stored data in DynamoDB: {item['issue_id']}")
        return True
    except Exception as e:
        logger.error(f"Error storing data in DynamoDB: {e}")
        return False

def lambda_handler(event, context):
    """
    When new folder with image & JSON metadata is created in S3, this lambda will be triggered
    to call Bedrock model for generating solution with knowledge base using Langchain RAG.
    Parameters:
        event: Dict containing the Lambda function event data
        context: Lambda runtime context
    Returns:
        Dict containing status message
    """
    try:
        # Log the incoming event
        logger.info(f"Received event: {json.dumps(event)}")
        
        # Get message from event triggered by S3
        record = event['Records'][0]
        bucket = record['s3']['bucket']['name']
        key = record['s3']['object']['key']
        
        logger.info(f"Processing S3 object: bucket={bucket}, key={key}")
        
        # 使用S3 object key作為issue_id的基礎
        # 將完整的S3 key儲存在raw_data中，讓validate_and_format_data函數處理
        
        # Process the metadata file
        logger.info(f"Downloading and parsing metadata from S3")
        
        # Download and parse JSON metadata
        json_content = download_file_from_s3(bucket, key)
        parsed_data = parse_json_metadata(json_content)
        formatted_metadata = parsed_data['formatted_text']
        raw_data = parsed_data['raw_data']
        
        # 將完整S3 key添加到raw_data中
        raw_data['s3_key'] = key
        logger.info(f"Added S3 key to raw_data: {key}")
        
        logger.info(f"Metadata parsed: {formatted_metadata}")
        
        # Initialize and run RAG chain
        logger.info("Initializing RAG chain")
        rag_chain = initialize_rag_chain()
        logger.info("Running query through RAG chain")
        solution = rag_chain.run(formatted_metadata)
        
        logger.info(f"RAG solution generated: {solution[:100]}...")
        
        # Store in DynamoDB using the raw data extracted from JSON
        logger.info("Storing data in DynamoDB")
        store_result = store_in_dynamodb(raw_data, solution)
        
        if store_result:
            # 從raw_data中提取最終使用的issue_id以記錄
            issue_id = key.split('/')[-1].split('.')[0]
            logger.info(f"Data successfully stored in DynamoDB with issue_id derived from key: {issue_id}")
        else:
            logger.error("Failed to store data in DynamoDB")
        
        return {
            'statusCode': 200,
            'body': json.dumps({
                'message': 'Analysis completed and data stored successfully',
                'issue_id': key.split('/')[-1].split('.')[0]  # 使用從key中提取的ID
            })
        }
    except Exception as e:
        logger.error(f"Error in lambda_handler: {str(e)}")
        return {
            'statusCode': 500,
            'body': json.dumps({
                'error': f"Error processing event: {str(e)}"
            })
        }